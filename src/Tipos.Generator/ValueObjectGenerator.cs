using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;

namespace Tipos.Generator
{
    [Generator]
    public class ValueOfGenerator : IIncrementalGenerator
    {
        private const string AttributeName = "ValueOfAttribute";
        private const string AttributeNamespace = "Tipos";

        private readonly string _attributeText = $@"// <auto-generated />
using System;

#pragma warning disable 1591

namespace {AttributeNamespace}
{{
    [AttributeUsage(AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
    internal sealed class {AttributeName}<TValue> : Attribute
    {{
    }}
}}
";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx => ctx.AddSource($"{AttributeName}.g.cs", _attributeText));

            var valueOfStructs = context.SyntaxProvider
                .ForAttributeWithMetadataName(
                    fullyQualifiedMetadataName: $"{AttributeNamespace}.{AttributeName}`1",
                    predicate: IsSyntaxTargetForGeneration,
                    transform: GetSemanticTargetForGeneration)
                .Where(static m => m is not null)
                .Collect();

            context.RegisterSourceOutput(valueOfStructs, Execute);

            static bool IsSyntaxTargetForGeneration(SyntaxNode node, CancellationToken _)
            {
                if (node is StructDeclarationSyntax structDeclarationSyntax)
                {
                    return structDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword);
                }

                if (node is RecordDeclarationSyntax recordDeclarationSyntax
                    && recordDeclarationSyntax.ClassOrStructKeyword.IsKind(SyntaxKind.StructKeyword))
                {
                    return recordDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword);
                }

                return false;
            }

            static ValueOfTarget? GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context, CancellationToken _)
            {
                if (context.TargetSymbol is not INamedTypeSymbol structSymbol)
                {
                    return null;
                }

                if (!structSymbol.IsValueType || !structSymbol.IsRecord)
                {
                    return null;
                }

                var attributeData = context.Attributes.FirstOrDefault();
                if (attributeData?.AttributeClass is null || attributeData.AttributeClass.TypeArguments.Length != 1)
                {
                    return null;
                }

                var valueTypeSymbol = attributeData.AttributeClass.TypeArguments[0];

                var @namespace = structSymbol.ContainingNamespace?.IsGlobalNamespace == true
                    ? string.Empty
                    : structSymbol.ContainingNamespace?.ToDisplayString() ?? string.Empty;

                return new ValueOfTarget(structSymbol, valueTypeSymbol, @namespace);
            }
        }

        private void Execute(SourceProductionContext context, ImmutableArray<ValueOfTarget?> targets)
        {
            foreach (var target in targets)
            {
                if (target is null)
                {
                    continue;
                }

                var structSymbol = target.Value.StructSymbol;
                var structName = structSymbol.Name;
                var valueType = target.Value.ValueTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var ns = target.Value.Namespace;
                var accessibility = GetAccessibility(structSymbol);
                var isReadOnly = structSymbol.IsReadOnly;

                var code = GenerateValueOfSource(structName, valueType, ns, accessibility, isReadOnly);
                var hintName = string.IsNullOrWhiteSpace(ns) ? structName : $"{ns}.{structName}";
                context.AddSource($"{hintName}.ValueOf.g.cs", code);
            }
        }

        private static string GenerateValueOfSource(string structName, string valueType, string nameSpace, string accessibility, bool isReadOnly)
        {
            var namespaceBlockStart = string.IsNullOrWhiteSpace(nameSpace)
                ? string.Empty
                : $"namespace {nameSpace}\n{{\n";

            var namespaceBlockEnd = string.IsNullOrWhiteSpace(nameSpace)
                ? string.Empty
                : "}\n";

            var typeIndent = string.IsNullOrWhiteSpace(nameSpace) ? string.Empty : "    ";
            var readOnlyKeyword = isReadOnly ? "readonly " : string.Empty;

            return $@"// <auto-generated/>
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

{namespaceBlockStart}{typeIndent}{accessibility} {readOnlyKeyword}partial record struct {structName} : IComparable<{structName}>
{typeIndent}{{
{typeIndent}    public {valueType} Value {{ get; }}

{typeIndent}    private {structName}({valueType} value)
{typeIndent}    {{
{typeIndent}        Value = value;
{typeIndent}    }}

{typeIndent}    [MethodImpl(MethodImplOptions.AggressiveInlining)]
{typeIndent}    public static {structName} From({valueType} value)
{typeIndent}    {{
{typeIndent}        Validate(value);
{typeIndent}        return new {structName}(value);
{typeIndent}    }}

{typeIndent}    [MethodImpl(MethodImplOptions.AggressiveInlining)]
{typeIndent}    public static bool TryFrom({valueType} value, out {structName} result)
{typeIndent}    {{
{typeIndent}        var isValid = true;
{typeIndent}        var handled = false;
{typeIndent}        TryValidate(value, ref isValid, ref handled);
{typeIndent}        if (handled)
{typeIndent}        {{
{typeIndent}            if (!isValid)
{typeIndent}            {{
{typeIndent}                result = default;
{typeIndent}                return false;
{typeIndent}            }}
{typeIndent}            result = new {structName}(value);
{typeIndent}            return true;
{typeIndent}        }}
{typeIndent}        try
{typeIndent}        {{
{typeIndent}            Validate(value);
{typeIndent}            result = new {structName}(value);
{typeIndent}            return true;
{typeIndent}        }}
{typeIndent}        catch
{typeIndent}        {{
{typeIndent}            result = default;
{typeIndent}            return false;
{typeIndent}        }}
{typeIndent}    }}

{typeIndent}    static partial void TryValidate({valueType} value, ref bool isValid, ref bool handled);

{typeIndent}    static partial void Validate({valueType} value);

{typeIndent}    [MethodImpl(MethodImplOptions.AggressiveInlining)]
{typeIndent}    public override string ToString() => Value.ToString();

{typeIndent}    public int CompareTo({structName} other) => Comparer<{valueType}>.Default.Compare(Value, other.Value);
{typeIndent}}}
{namespaceBlockEnd}";
        }

        private static string GetAccessibility(INamedTypeSymbol symbol)
        {
            return symbol.DeclaredAccessibility switch
            {
                Accessibility.Public => "public",
                Accessibility.Internal => "internal",
                Accessibility.Private => "private",
                Accessibility.Protected => "protected",
                Accessibility.ProtectedAndInternal => "private protected",
                Accessibility.ProtectedOrInternal => "protected internal",
                _ => "internal"
            };
        }

        private readonly record struct ValueOfTarget(INamedTypeSymbol StructSymbol, ITypeSymbol ValueTypeSymbol, string Namespace);
    }
}